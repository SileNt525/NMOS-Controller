“Roo Code” NMOS 控制软件详细开发计划
1. 执行摘要
项目愿景：“Roo Code” 旨在成为一款基于 NMOS 标准的先进控制系统，为 IP 广播设备提供直观且强大的管理能力。其功能将对标 Pebble Control 等成熟解决方案，重点实现对 NMOS IS-04、IS-05、IS-07 及 IS-08 标准的全面兼容，提供高度直观的网页用户界面，并支持事件触发路由等高级功能。
核心目标：
为 NMOS 设备的发现、注册和连接管理提供一个可靠的平台。
实现包括音频通道映射在内的复杂路由控制。
通过 IS-07 事件驱动机制，实现动态工作流程自动化。
借助现代化的网页前端，提供“美观直观”的用户体验。
拟议方法： 开发将遵循模块化、分阶段的方法，首先优先实现核心 NMOS 功能，随后开发用户界面及高级特性。系统架构将着重考虑可扩展性与可维护性，后端可能采用事件驱动的微服务模式，前端则选用现代 JavaScript 框架。开发过程中将审慎评估并集成或参考现有的开源 NMOS 库，以加速开发进程并确保标准符合性。
关键差异化（目标）： 虽然与 Pebble Control 功能相似，但 Roo Code 可通过极其直观的用户界面、可能更灵活的事件触发逻辑，以及从一开始就采用现代最佳实践构建的高度可扩展和高弹性的后端架构，来实现差异化竞争。
2. Roo Code 项目的 NMOS 基础
2.1. NMOS 在现代 IP 广播中的角色
网络化媒体开放规范 (NMOS) 由高级媒体工作流协会 (AMWA) 制定，为 IP 媒体工作流中的互操作性提供了标准化的控制和管理层，是对 SMPTE ST 2110 等传输标准的补充 。它解决了 ST 2110 仅规范传输层，而未涉及设备发现或连接管理的问题 。若缺乏 NMOS，各种专有解决方案将充斥市场，从而阻碍互操作性 。Roo Code 将利用 NMOS 确保与各类供应商设备的无缝集成，为用户提供灵活性并避免厂商锁定 。   

采纳 NMOS 不仅是一项技术选择，更是一项战略决策，它将 Roo Code 定位为不断发展的 IP 广播领域中一个开放、可互操作的解决方案。这与行业内采用商用现成 (COTS) 硬件和软件定义工作流的趋势相符 。广播行业正逐步向 IP 化转型 ，ST 2110 标准化了 IP 网络上的媒体传输 。然而，ST 2110 并未涵盖设备发现、注册或连接管理 。如果这一空白由专有解决方案填补，将会引发互操作性问题 。AMWA 的 NMOS 规范通过为这些控制平面功能提供开放标准来填补这一空白 。因此，基于 NMOS 构建 Roo Code 对于其市场接受度以及在多厂商环境下的运作能力至关重要，这也是用户的核心受益点 。   

2.2. 项目关键 NMOS 规范概述
对项目所涉及的 NMOS 标准建立基础的理解，对于 Roo Code 开发团队至关重要。这些规范并非单一的整体，而是被设计为可组合的构建模块 。下表为开发团队提供了快速参考，总结了每个强制性 NMOS 规范的核心功能及其与 Roo Code 项目的相关性。清晰简明的摘要有助于团队统一认识，并对 NMOS 集成的范围形成共同理解。   

表1：Roo Code 项目 NMOS 规范概览

规范 ID	全称	Roo Code 核心用途	AMWA 关键文档参考
IS-04	AMWA IS-04 NMOS 发现与注册规范	使 Roo Code 能够发现网络中的 NMOS 设备 (Node)，了解其能力 (Device, Sender, Receiver, Source, Flow)，并维护实时清单。允许 NMOS 设备向 NMOS 注册中心注册，Roo Code 将查询该注册中心。 	https://specs.amwa.tv/is-04/
IS-05	AMWA IS-05 NMOS 设备连接管理规范	使 Roo Code 能够建立、修改和移除 NMOS Sender 和 Receiver 之间的连接。这是路由控制的核心。支持多种传输类型 (RTP, MQTT, WebSocket) 和激活模式 (立即, 延迟)。 	https://specs.amwa.tv/is-05/
IS-07	AMWA IS-07 NMOS 事件与 Tally 规范	使 Roo Code 能够订阅和处理来自 NMOS 设备的实时事件 (如 Tally 状态变化、按钮按下)。关键在于，这些事件可以触发通过 IS-05 实现的路由变更。支持布尔型、字符串、数字等数据类型。通过 MQTT 或 WebSocket 传输。 	https://specs.amwa.tv/is-07/
IS-08	AMWA IS-08 NMOS 音频通道映射规范	使 Roo Code 能够在 NMOS 环境中执行详细的音频通道管理，例如静音、交换或重新路由单个音频通道。扩展了 IS-05 的能力。 	https://specs.amwa.tv/is-08/
  
这些规范之间的相互作用至关重要。IS-04 提供了“什么”（设备及其能力），IS-05 提供了“如何做”（连接它们的方法），IS-07 提供了“何时”（连接的事件触发器），而 IS-08 则增加了“粒度”（针对音频连接）。Roo Code 必须将这些规范实现为一个集成的系统，而非孤立的模块。具体而言，IS-04 使 Roo Code 能够获知网络中所有的 Sender 和 Receiver 。IS-05 则允许 Roo Code 指示一个 Receiver 连接到指定的 Sender 。IS-07 使得外部事件（例如，摄像机的 Tally 灯状态，这是一个 IS-07 事件源）能够被发送至 Roo Code 。Roo Code 随后可以利用这个 IS-07 事件作为触发器，来发起一个 IS-05 连接命令（例如，将摄像机的输出路由到特定的监视器）。IS-08 通过允许按需映射该摄像机流中的特定音频通道，进一步完善了这一流程 。这清晰地展示了事件触发路由功能的因果链条。   

2.3. 核心 NMOS 数据模型 (Node, Device, Sender, Receiver, Flow, Source)
理解 NMOS 数据模型对于后端开发、数据库设计以及用户界面呈现至关重要 。   

Node (节点): NMOS 资源的逻辑主机，可以是物理设备或虚拟机 。Roo Code 将发现节点。   
Device (设备): 节点内功能的逻辑分组 (例如，摄像机节点内的摄像机设备) 。Roo Code 将显示设备及其能力。   
Source (源): 内容的抽象起点 (例如，视频传感器、音频输入) 。源产生流。   
Flow (流): 内容的具体表示 (例如，来自源的特定视频格式) 。流是发送器传输和接收器消耗的对象。   
Sender (发送器): 设备上的“虚拟输出端口”，用于通过网络传输流 。Roo Code 将控制哪些发送器处于活动状态。   
Receiver (接收器): 设备上的“虚拟输入端口”，用于从网络接收流 。Roo Code 将把接收器连接到发送器。   
关系: Node -> Device ->, Device -> Sender, Device -> Receiver。
NMOS 数据模型的层级和关系特性  直接影响 Roo Code 应如何构建其内部数据表示，以及如何在用户界面中呈现网络拓扑和设备关系。此处的任何不匹配都可能导致数据处理效率低下或用户体验混乱。IS-04 规范  定义了这些资源及其层级结构。Roo Code 的后端需要存储和管理这些资源及其关系。用户界面需要可视化地呈现这种层级结构（例如，一个节点包含多个设备，而设备又包含发送器/接收器）。如果 Roo Code 的内部数据模型未能准确反映 NMOS 模型，那么在 API 调用或用户界面显示时进行两者之间的转换将会变得复杂且容易出错。因此，Roo Code 内部数据结构的设计应紧密参照 NMOS 数据模型。   

3. 系统架构设计
3.1. 后端架构
推荐采用事件驱动的微服务架构。此架构模式与 NMOS 规范的独立功能特性（IS-04、IS-05、IS-07、IS-08 可作为独立服务）高度契合，有利于模块化开发 。各个服务可以根据负载独立扩展（例如，应对大量的 IS-07 事件）。同时，单个微服务（如 IS-08 映射服务）的故障不太可能导致整个系统瘫痪，这得益于舱壁隔离模式 (Bulkhead pattern) 的应用 。该架构还允许为每个服务选择最适合的技术栈。其事件驱动的本质天然支持 IS-07 事件触发需求和实时更新 。   

核心服务组件（微服务）规划如下：

NMOS 注册服务 (IS-04):
处理与外部 NMOS 注册中心的交互（通过查询 API 进行发现，通过 WebSocket 订阅获取 IS-04 资源的实时更新）。   
管理已发现 NMOS 资源（Node、Device、Sender、Receiver、Source、Flow）的内部缓存/数据库。
为 Roo Code 的其他服务提供访问此 NMOS 清单的内部 API。
连接管理服务 (IS-05):
暴露用于发起和管理连接的内部 API。
将内部路由请求转换为对设备 Sender/Receiver 的 IS-05 PATCH 请求（针对 /staged、/active 端点）。   
管理传输参数（例如，从 Sender 的 /transportfile 获取 RTP 的 SDP 文件）。   
处理单播、组播、立即激活和延迟激活的逻辑 。   
通过 NMOS 注册服务监控 IS-04 资源更新（例如 Sender/Receiver 的 subscription 属性），从而监控连接状态 。   
事件处理服务 (IS-07):
管理对 NMOS 设备上 IS-07 事件源的订阅（通过 IS-05 配置的 WebSocket 或 MQTT）。   
处理传入的 IS-07 事件（例如 Tally 状态变更）。
包含将特定 IS-07 事件转换为动作（例如通过连接管理服务触发路由变更）的逻辑。这是“IS-07 事件（如 Tally）触发控制路由”功能的核心所在 。   
音频映射服务 (IS-08):
暴露用于音频通道映射操作的内部 API。
将内部请求转换为对 NMOS 设备的 IS-08 命令 。   
与 IS-04 协调进行资源识别，并与 IS-05 协调管理涉及特定音频映射的连接。
API 网关:
作为所有前端请求的单入口点。
将请求路由到相应的后端微服务。
处理认证、授权以及可能的速率限制 。   
通知服务:
管理对 Web UI 的实时更新（例如，通过 WebSocket）。   
从其他服务接收状态变更信息（例如，发现新设备、连接已激活、事件发生）并将其推送给连接的 UI 客户端。
服务间的通信协议建议采用异步消息传递（例如 Kafka、RabbitMQ、Redis Streams）用于服务间通信，特别是对于不需要立即同步响应的事件和命令，这能增强松耦合和弹性 。对于需要服务间立即响应的请求，可审慎使用同步通信（例如 gRPC 或 RESTful HTTP 调用）。   

虽然微服务架构具有诸多优势，但也引入了部署、服务间通信和分布式数据管理方面的复杂性。开发计划必须认识到这些挑战，并提出应对策略（例如，使用 Docker/Kubernetes 进行容器化、采用健壮的消息队列、实施分布式追踪）。用户期望构建一个类似 Pebble Control 的系统，该系统支持 IS-04、IS-05、IS-07、IS-08 。这些功能各不相同但又相互关联。单体后端可能会变得复杂且难以扩展/维护 。微服务允许将这些关注点分离 。例如，IS-04 发现是一个持续的后台进程，而 IS-05 连接管理是命令驱动的，IS-07 则是事件驱动的。这些不同的特性非常适合于可以独立开发、部署和扩展的独立服务。IS-07 事件触发 IS-05 动作的事件驱动特性  强烈建议采用事件驱动的骨干网络进行服务间通信 。   

3.2. 前端架构
Web UI 技术栈推荐采用现代 JavaScript 框架，如 React、Vue.js 或 Angular。React 拥有庞大的生态系统，采用基于组件的开发模式，适合构建复杂的用户界面，并且有开源的 NMOS UI 实现可供参考 (如 Sony 的 nmos-js )。Vue.js 是一个渐进式框架，对某些开发者而言学习曲线较为平缓，且性能良好。Angular 是一个全面的框架，适用于大型企业级应用，但其风格较为固定。这些框架为构建动态、响应式和可维护的用户界面提供了强大的工具，这对于实现“美观直观”的用户体验至关重要。基于组件的架构有助于管理 UI 的复杂性。   

客户端状态管理推荐使用 Redux (配合 React)、Vuex (配合 Vue) 或 NgRx (配合 Angular) 等库。这对于管理复杂的应用状态至关重要，尤其是在处理来自后端的实时更新（例如设备状态、活动连接）时 。   

API 交互层应设立一个专用层（例如，使用 Axios 或 Fetch API）来处理与后端 API 网关的通信，负责请求/响应格式化、错误处理和认证令牌的管理。

实时 UI 更新将通过 WebSocket 实现，由后端通知服务向所有连接的 Web UI 客户端推送状态变更（例如设备上线/离线、连接变更、Tally 等 IS-07 事件）。   

前端必须高度响应并能实时反映 IP 媒体网络的当前状态。框架的选择应考虑团队的专业技能，但架构必须优先考虑高效的状态管理和实时通信。用户界面需要显示动态信息：已发现的设备 (IS-04)、它们的连接状态 (IS-05) 以及诸如 Tally 之类的传入事件 (IS-07)。这些数据会实时变化。传统的请求-响应轮询效率低下。WebSocket  是后端向前端推送更新的理想选择。需要一个强大的客户端状态管理解决方案（如 Redux ）来处理这些异步更新并保持用户界面的一致性。   

3.3. 数据库与数据持久化
数据库的选择可能需要组合使用多种技术。主要数据库（例如 PostgreSQL、MySQL）可用于存储结构化数据，如 NMOS 资源清单（Node、Device、Sender、Receiver、Source、Flow 及其属性和关系）、用户配置和审计日志。关系型数据库提供 ACID 事务特性和强一致性 。NMOS IS-04 数据模型  为数据库模式设计提供了坚实的基础。缓存/内存数据库（例如 Redis）可用于存储频繁访问的数据、会话管理，以及在需要轻量级解决方案时作为服务间通信的消息代理 。可选地，如果需要详细的历史事件记录或 NMOS 事件/状态的性能监控，可以考虑使用时序数据库（例如 InfluxDB、Prometheus）。   

数据库模式设计需考虑以下方面：

NMOS 资源清单： 为 Node、Device、Sender、Receiver、Source、Flow 创建表。关系是关键（例如，Device 的 parent_node_id，Sender 的 parent_device_id，Flow 的 source_id）。属性将基于 NMOS JSON 模式定义（例如，Node 参考 ，Sender 参考 ）。   
连接状态： 持久化期望/暂存的连接和活动连接状态，将 Sender 与 Receiver 及其相关传输参数关联起来。IS-05 中 Receiver 上的 sender_id 和 Sender 上的 receiver_id 在此至关重要 。   
用户配置： 存储用户偏好、自定义视图、已保存的路由配置。
IS-07 事件定义/规则 (如果可配置)： 如果 Roo Code 允许用户定义 IS-07 事件如何触发 IS-05 动作的规则，则需要持久化这些规则。
标识符持久性： NMOS 强制要求资源使用持久性 UUID 。数据库必须将这些 UUID 存储为主键。   
数据持久化模式方面，在 Active Record 和 Data Mapper 之间，Data Mapper  通常更适合微服务架构，以保持服务与数据库模式细节的独立性。   

实时控制系统中的数据持久化必须在一致性与性能之间取得平衡。虽然 NMOS 注册中心提供实时视图，但 Roo Code 需要自己的持久化存储来保存历史数据、用户配置，并可能在重启后重建状态。数据库技术的选择应反映数据类型和访问模式。NMOS 设备向 IS-04 注册中心注册 ，Roo Code 查询此注册中心。然而，为提高性能，本地缓存此数据至关重要。对于用户特定的配置（如自定义视图、保存的路由预设 ），Roo Code 需要自己的数据库。连接状态（哪个发送器连接到哪个接收器）也需要跟踪并可能持久化，以用于审计或恢复 。IS-04 本身定义了一个丰富的数据模型 ，可以直接为数据库模式提供信息。   

表2：拟议技术栈

组件领域	推荐技术	Roo Code 的理由/主要优势
后端服务	语言: Python/Node.js/Java/Go (根据团队专长、库的可用性如 nmos-cpp 绑定或健壮的 HTTP/WebSocket 库选择)。框架: (例如 FastAPI/Express.js/Spring Boot/Go-kit)	选择标准：高性能、易于开发网络服务、强大的异步能力。
前端 UI	框架: React (配合 Redux)	生态系统丰富，基于组件，适合复杂的实时 UI，已有 NMOS UI 示例 (nmos-js )。
数据库	主要: PostgreSQL。缓存: Redis。	PostgreSQL 用于 NMOS 实体和配置的健壮关系数据存储；Redis 用于缓存频繁访问的数据和可能的会话管理。
消息队列	Apache Kafka 或 RabbitMQ	用于事件驱动微服务架构中可靠的异步服务间通信。
容器化	Docker, Kubernetes	用于微服务的一致性部署、可扩展性和管理。
4. 模块化开发计划
4.1. 模块：IS-04 发现与注册引擎
此模块的核心职责是使 Roo Code 能够准确、实时地感知网络中所有 NMOS 设备的拓扑结构和能力。

与外部 NMOS 注册中心的接口：
注册中心发现： 必须实现 DNS-SD（包括 mDNS 和单播 DNS）以发现 IS-04 注册和查询 API 端点 。对于大型部署，首选单播 DNS-SD 。   
资源查询： 利用 IS-04 查询 API（HTTP GET 请求）获取已注册的 Node、Device、Sender、Receiver、Source 和 Flow 的列表 。为了应对大规模注册中心，必须支持分页和 RQL (Registry Query Language) 高级过滤 。   
实时更新： 建立到查询 API 的 /subscriptions 端点的 WebSocket 连接，以接收 NMOS 资源的实时更新（增、删、改）。这对于维护网络视图的即时性至关重要。   
IS-04 资源数据的管理与存储：
需要设计内部数据结构来表示每种 NMOS 资源类型（Node、Device、Sender、Receiver、Source、Flow），并使其与各自的 JSON 模式定义保持一致 。   
这些数据将持久化存储在主要数据库中（例如 PostgreSQL）。
处理从注册中心观察到的资源心跳和垃圾回收逻辑（Node 向注册中心发送心跳；注册中心执行垃圾回收。Roo Code 通过查询 API 更新观察结果）。   
表3：IS-04 关键资源摘要

资源类型	关键属性 (示例)	Roo Code 中的用途	关键属性参考 (JSON Schema)
Node	id, label, href, services, api.endpoints, interfaces	代表物理或虚拟主机；Roo Code 用于理解网络拓扑和访问节点 API。	node.json 
Device	id, label, node_id, senders (UUID 数组), receivers (UUID 数组), controls	功能的逻辑分组；Roo Code 用于组织 Sender/Receiver 和访问特定于设备的控制 (如 IS-05, IS-08)。	device.json 
Sender	id, label, flow_id, transport, manifest_href, interface_bindings, subscription.active, subscription.receiver_id	代表输出流；Roo Code 将这些连接到 Receiver。	sender.json 
Receiver	id, label, format, caps, transport, interface_bindings, subscription.active, subscription.sender_id	代表输入流；Roo Code 将这些连接到 Sender。	receiver.json (及其子类型如 receiver_video.json, receiver_audio.json) 
Source	id, label, format, device_id, parents, clock_name	媒体流的起源；为 Flow 提供上下文。	source.json (及其子类型) 
Flow	id, label, source_id, format, media_type, parents	媒体的具体表示；Sender 传输 Flow。	flow.json (及其

子类型) 
  
Roo Code 的可靠性在很大程度上取决于此模块的稳健性。高效处理来自众多注册中心的 WebSocket 更新并准确反映网络状态至关重要。对于注册中心不可用或消息格式错误等情况的错误处理机制也必须周全。Roo Code 需要了解网络上的设备才能对其进行控制。IS-04 提供了这一功能 。设备向 NMOS 注册中心注册。Roo Code 作为此注册中心的客户端，使用查询 API 获取初始资源列表，并通过 WebSocket 获取持续更新 。这些数据必须由 Roo Code 在内部存储和管理。此内部表示的准确性直接影响用户控制网络的能力。如果发现功能存在缺陷，控制将无从谈起。   

4.2. 模块：IS-05 连接管理核心
此模块负责执行实际的媒体流路由操作。

实现 IS-05 Sender 和 Receiver 客户端逻辑：
连接管理服务将作为 IS-05 客户端，向已发现设备上的 NMOS Sender 和 Receiver 的 /staged 端点发送 HTTP PATCH 请求 。   
需要构建这些 PATCH 请求的 JSON 负载，包括 activation 对象（模式：activate_immediate、activate_scheduled_absolute、activate_scheduled_relative）、master_enable、sender_id（用于 Receiver）、receiver_id（用于 Sender）和 transport_params 。   
处理传输参数：
对于基于 RTP 的 Sender（在 ST 2110 中常见），从 Sender 的 /transportfile 端点获取 SDP 文件 。   
此 SDP 数据（或相关部分）将在修补 Receiver 的 /staged 端点时包含在 transport_file 或 transport_params 对象中 。   
如果 IS-07 或其他用途需要，还需支持其他传输类型（如 IS-05 定义的 MQTT、WebSocket）。   
单次、批量、立即和延迟激活的逻辑：
实现制定单个 Sender/Receiver 变更请求的逻辑。
实现使用 IS-05 /bulk 端点处理同一设备上的多个变更，以减少网络开销 。   
支持 activate_immediate 以进行直接路由变更。
如果需要计划激活，则管理这些激活的时序和触发。
与 IS-04 资源的状态同步：
成功的 IS-05 激活后，设备上的 IS-04 Sender/Receiver 资源应更新其 subscription 对象（例如，Sender 上的 receiver_id，Receiver 上的 sender_id，以及 active 状态）。   
此模块应通过 IS-04 发现与注册引擎接收到的更新来验证这些变更。这确认了连接在 NMOS 层面已成功建立。
检查约束： 在尝试 PATCH Sender 或 Receiver 之前，Roo Code 应当查询其 /constraints 端点，以了解 transport_params 的允许值 。   
原子性和错误处理至关重要。如果 IS-05 PATCH 请求失败会怎样？Roo Code 如何回滚或报告错误？如果多个用户或自动化的 IS-07 触发器同时尝试控制同一资源，如何处理冲突？一个健壮的连接请求状态机将是必要的。一旦设备被发现 (IS-04)，用户便希望建立连接（路由媒体）。IS-05 定义了如何执行此操作 。Roo Code 需要向设备发送 IS-05 命令 (HTTP PATCH)。这些命令包含连接参数，通常来自 SDP 文件 。然后设备根据这些命令采取行动。Roo Code 需要通过检查相关 Sender/Receiver 更新后的 IS-04 状态来确认连接 。这为连接管理创建了一个闭环。复杂性在于管理不同的激活模式，并通过检查设备约束来确保命令的有效性 。   

4.3. 模块：IS-07 事件与 Tally 系统
该模块是实现动态、自动化工作流的关键。

实现 IS-07 事件消费者：
事件处理服务将订阅 IS-07 事件源。这包括：
通过 IS-04 发现 IS-07 源（它们是 NMOS 资源）。   
使用 IS-05 建立到 IS-07 事件传输（WebSocket 或 MQTT）的连接。IS-07 Receiver 的 IS-05 transport_params 将指定 WebSocket URI 或 MQTT 代理详细信息和主题 。   
事件订阅机制：
对于 WebSocket：实现客户端逻辑以连接到 IS-07 源的 WebSocket 端点，并为特定的事件 source_id 发送订阅命令。处理心跳以维持连接 。   
对于 MQTT：实现 MQTT 客户端以连接到代理并订阅相关主题 。   
处理 IS-07 事件：
解析传入的事件消息（JSON 格式）。   
理解事件数据类型（布尔型、字符串、数字，以及根据 IS-07 类型定义可能存在的枚举或对象 ）。   
提取相关信息，例如 Tally 状态（例如，布尔值 true 表示直播中）。
触发 IS-05 连接管理动作：
这是“事件触发路由”的核心。
在事件处理服务中实现规则引擎或可配置逻辑。
示例工作流程：
Roo Code（事件处理服务）订阅来自摄像机 A 的 IS-07 Tally 事件源。
摄像机 A 进入直播状态；其 IS-07 源发出事件：{ "state": { "urn:x-nmos:event:tally": true }, "type": "boolean",... }。
事件处理服务接收并处理此事件。
规则引擎确定“摄像机 A Tally ON”应触发将摄像机 A 的视频（一个 IS-04 Sender）路由到预览监视器 1（一个 IS-04 Receiver）。
事件处理服务指示连接管理服务 (IS-05) 建立此连接。
连接管理服务执行 IS-05 PATCH 请求。
此逻辑需要将 IS-07 源 ID 映射到 IS-04 Sender/Receiver ID 和预定义的路由目标。此映射可在 Roo Code UI 中由用户配置。
Pebble Control 展示了类似的功能：“基于 ISO7 的逻辑控制按钮组”和“触发连接管理模块，然后使用 ISO5 重新配置...”。   
表4：Roo Code 的 IS-07 事件类型与处理

IS-07 事件类型 (示例)	数据类型	典型来源	Roo Code 解读	相应 IS-05 动作 (预定义或用户可配置)
urn:x-nmos:event:tally (或更具体的 Tally URN)	布尔型	摄像机, 切换台输出	true = 直播/预监, false = 非直播	若为 true，则将关联的 IS-04 Sender 路由到预配置的“直播监视器”Receiver。若为 false，则路由到“非直播/默认”Receiver 或清除路由。
urn:x-nmos:event:buttonPress	布尔型	控制面板按钮	true = 按钮按下	触发预定义的 IS-05 路由切换或执行用户配置的宏。

导出到 Google 表格
IS-07 中“Tally”事件的定义可能比较通用。Roo Code 可能需要允许用户将特定的 IS-07 事件 source_id 及其状态（例如，某个布尔事件变为 true）映射到特定的路由操作。这意味着 Roo Code 内部需要一个灵活的映射/规则配置。IS-05 中的 ext_is_07_rest_api_url 参数  可供 IS-07 接收器用于获取有关事件源的更多上下文信息。用户明确要求“IS-07 事件（如 Tally）触发控制路由”。IS-07 定义了事件的发布和订阅方式 。IS-05 用于建立实际连接 。因此，Roo Code 需要一个模块来：1. 订阅 IS-07 事件（例如，来自摄像机的 Tally 事件）。2. 解释事件（例如，Tally 为 ON）。3. 根据此事件决定采取何种路由操作（这是“逻辑”部分，可能由用户配置）。4. 命令 IS-05 模块执行该路由操作。这需要在 Roo Code 后端的 IS-07 事件消费者和 IS-05 连接发起者之间建立清晰的接口。Pebble Control 的示例  证实了这是一个有效且理想的工作流程。   

4.4. 模块：IS-08 音频通道映射
此模块将为用户提供对音频流内部通道的精细控制。

实现音频通道映射操作的逻辑：
音频映射服务将处理静音通道、交换语言（意味着重新映射通道）等请求 。   
这涉及构建适当的 IS-08 API 请求（可能是对 NMOS 设备上特定 IS-08 端点的 PATCH 或 POST 请求）。   
控制音频映射的 API 端点：
该服务将暴露一个内部 API，供 Roo Code UI 或其他服务请求音频映射变更。
与 IS-04/IS-05 的集成：
IS-04 用于发现支持 IS-08 的 Node 和 Device（通过其 Device 资源中的 controls 数组，其中会列出 IS-08 控制端点 ）。   
IS-08 操作通常在现有的 IS-05 连接上执行，或者在连接建立之前对 Sender/Receiver 执行。控制器从发送节点获取通道信息，并将映射信息发送到接收节点（也可以进行发送端映射）。   
IS-08 为音频控制增加了一个粒度层。其用户界面需要精心设计，以便用户能够轻松可视化和操作特定 Sender 或 Receiver 的音频通道映射。“控制器从发送节点获取通道信息……并将映射信息发送到接收节点” 的交互模型意味着 Roo Code 的后端必须协调一个多步骤过程。基础的 IS-05 路由连接的是整个 Flow。IS-08 允许在音频 Flow 内部进行更精细的控制 。为了让 Roo Code 支持此功能，它需要：1. 识别哪些设备支持 IS-08（通过 IS-04）。2. 允许用户选择一个音频 Sender 或 Receiver。3. 查询设备的当前音频通道状态/能力（使用 IS-08 API）。4. 将此信息呈现给用户，并允许他们定义新的映射（例如，静音通道 2，交换左/右声道）。5. 使用 IS-08 API 命令将新的映射发送到设备。这与 IS-05 连接管理不同，但对其进行了补充。   

4.5. 模块：Web 用户界面 (UI/UX)
用户界面的设计目标是实现“美观直观”，同时能够有效管理复杂的 IP 媒体网络。

直观广播控制 UI 的设计原则：
清晰性与可读性： 使用清晰的字体、足够的对比度和逻辑布局。垂直列表通常优于水平列表 。   
一致性： 重要按钮和信息的位置应保持一致 。   
最少点击： 目标是从主屏幕通过 2-3 次点击即可访问关键功能 。   
反馈： 为用户操作和系统状态变更提供即时视觉反馈（例如，离线设备警报 ，连接状态更新）。   
错误预防： 设计应最大限度减少错误；关键操作使用确认提示 。   
**面向任务的设计：**围绕广播操作的用户工作流程构建 UI 。   
Pebble Control 采用基于 Web 的 UI 。   
关键 UI 组件：
网络拓扑可视化：
已发现 Node、Device 及其互连的图形表示。
使用颜色编码或图标指示设备状态（在线、离线、错误）、类型和连接状态 。   
具备缩放、平移和过滤功能。
设备状态仪表盘：
所有关键设备、其运行状况和关键参数的概览。
突出显示警报和通知（Pebble Control 具有警报功能 ）。   
连接矩阵/路由界面：
查看和创建/修改 Sender 与 Receiver 之间连接的直观方式。
可以是传统的矩阵视图，也可以是拓扑视图上更图形化的拖放界面。
清晰显示活动路由、暂存变更和传输参数（例如，悬停/点击时显示 SDP 详细信息）。
Pebble Control 提供“简化的连接管理”和“自定义逻辑视图和容器”。   
事件日志与 Tally 显示：
重要 IS-07 事件、系统警报和用户操作的实时日志。
清晰显示相关设备/源的 Tally 状态。
配置面板：
用于设置 IS-07 事件到动作的规则。
用于管理 IS-08 音频通道映射。
用于系统设置、用户管理等。
Pebble Control 允许管理组播设置 。   
IS-08 音频通道映射界面：
所选 Sender/Receiver 音频通道的可视化表示。
用于静音、增益调整（如果设备和 IS-08 模型支持）以及重新路由/交换通道的控件。
手动路由与事件触发路由可视化的工作流程：
手动路由：用户选择 Sender 和 Receiver，必要时配置参数，然后应用连接。UI 显示待处理和活动状态。
事件触发路由：UI 应允许配置“如果发生 IS-07 事件 X，则执行 IS-05 动作 Y”。UI 还应清晰指示路由何时因事件而自动建立或更改。
UI 的成功取决于其在提供强大控制能力的同时，能否有效抽象 NMOS 的复杂性。它必须满足那些了解广播工作流程但可能不是 NMOS 专家的用户的需求。可视化 NMOS 数据模型中定义的逻辑关系（Node->Device->Sender/Receiver）是关键 。用户期望一个“美观直观”的用户界面。广播控制系统管理着复杂的网络。NMOS 本身拥有一个详细的数据模型。因此，用户界面必须以简单的方式有效地可视化这种复杂性。关键任务包括查看网络上的内容（来自 IS-04 的发现）、建立连接 (IS-05)、查看诸如 Tally 之类的事件状态 (IS-07) 以及映射音频 (IS-08)。这些都需要专门但集成的用户界面组件。HMI 设计的最佳实践（如清晰导航、最少点击次数和良好的视觉反馈） 在此直接适用。Pebble Control 的特性（如物理/逻辑视图和警报） 提供了很好的参考。   

5. 关键技术实现细节
5.1. 利用开源库
审慎利用现有开源库可以显著加速开发进程并提高标准的符合性。

nmos-cpp (Sony) 评估：
提供 NMOS 注册中心和节点的 C++ 实现，支持 IS-04、IS-05、IS-07、IS-08、IS-09、IS-10、IS-12 。   
该库成熟稳定，已在 JT-NM Tested 项目中使用并被多家供应商采用 。   
其架构包含 NMOS 资源的数据模型和 REST API 实现 。   
Roo Code 策略： 如果采用 C++ 开发，可将其用作核心库；如果使用其他语言，可作为行为和 API 交互的权威参考。其数据模型（nmos::resources, nmos::resource ）是 Roo Code 内部状态管理的良好范例。   
nmos-js (Sony) 评估：
用于 IS-04、IS-05、IS-08（只读）、BCP-004-01 的 JavaScript 客户端 。   
基于 React，可作为 Roo Code 前端 UI 结构和从 JavaScript 与 NMOS API 交互的示例。
Roo Code 策略： 主要作为前端开发的参考，特别是在从 Web 客户端与 IS-04 查询 API 和 IS-05 连接 API 交互方面。
NvNmos (NVIDIA) 评估：
用于创建 NMOS 节点的库，内部使用 nmos-cpp。支持 IS-04、IS-05、IS-09、BCP 等规范 。   
Roo Code 策略： 对于构建控制器而言，直接适用性较低，但有助于理解节点端的行为和 nmos-cpp 的集成方式。
AMWA nmos-device-control-mock 评估：
基于 Typescript/Node.js 的模拟 NMOS 设备，支持 IS-04、IS-05、IS-12、MS-05-02、BCP 等规范 。   
Roo Code 策略： 在 Roo Code 开发过程中极具价值。可在物理硬件到位之前或针对特定测试场景模拟 NMOS 设备。
AMWA NMOS 测试工具评估：
用于测试 NMOS 实现（节点、注册中心，现也包括控制器）的开源工具 。   
Roo Code 策略： 对于验证 Roo Code 是否符合 NMOS 规范，特别是其作为 NMOS 控制器的行为，至关重要。
明智地使用这些库，特别是将 nmos-cpp 作为参考或核心（如果使用 C++），并将 nmos-device-control-mock / NMOS 测试工具用于开发和测试，可以显著缩短开发时间并提高合规性。然而，如果仅需要客户端功能，将像 nmos-cpp 这样的完整节点库直接嵌入控制器可能有些过度。一个定制的、轻量级的客户端实现可能更合适，同时将这些库作为指南。从头开始构建所有内容既耗时又容易出错，特别是对于像 NMOS 这样复杂的规范。现有开源实现 。nmos-cpp 是一个全面的 C++ 库，适用于节点和注册中心 。nmos-js 是一个 JavaScript 客户端 。Roo Code 是一个控制器。如果 Roo Code 的后端是 C++，则可以调整或使用 nmos-cpp 的部分客户端逻辑或数据模型。如果不是 C++，它们可以作为极好的参考。nmos-js 是前端的一个良好参考。无论 Roo Code 的实现语言如何，模拟设备  和测试工具  对于开发都具有不可估量的价值。   

5.2. 实时状态同步
确保前端用户界面和后端服务都能准确、及时地反映网络中 NMOS 设备的真实状态是控制系统的核心要求。

后端到前端的同步：
利用由通知服务管理的 WebSocket，将状态变更（设备发现、连接状态、IS-07 事件）推送给所有连接的 Web UI 客户端 。   
客户端状态管理库（Redux、Vuex）将处理这些更新并重新渲染 UI 组件。
控制器后端状态同步：
NMOS 注册服务根据 IS-04 查询 API WebSocket 订阅持续更新其内部清单。
其他服务（连接管理、事件处理）依赖此最新清单。
由 Roo Code 进行的更改（例如 IS-05 连接）应通过 IS-04 机制反映回来（设备更新其发送器/接收器，注册中心通知 Roo Code）。这提供了一个闭环确认 。   
分布式状态管理（如果采用微服务）：
确保微服务之间的一致性。对于某些数据，最终一致性通常是可以接受的，但关键状态（例如活动连接锁）可能需要更强的一致性机制或单一事实来源服务 。   
使用可靠的消息总线有助于一致地传播状态更改。
实时准确性至关重要。反映网络状态变化的延迟可能导致用户混淆或错误的控制操作。架构必须最大限度地减少此类延迟。冲突解决（例如，如果外部系统更改了 Roo Code 也试图更改的路由）需要加以考虑。NMOS IS-04 资源上的版本时间戳是检测更改的关键 。控制系统必须反映网络的实际情况。NMOS 设备的状态可以改变（连接、断开、新事件）。IS-04 注册中心通过 WebSocket 更新 。Roo Code 订阅这些更新。当 Roo Code 收到更新时，其内部状态会发生变化。然后，此更改必须推送给任何连接的 Web UI，也可能通过 WebSocket 。如果 Roo Code 本身发起更改（例如 IS-05 连接），理想情况下，它应等待该更改的确认通过 IS-04 更新循环返回，以确保设备已确认并应用了更改 。   

5.3. 可扩展性与弹性
随着 IP 广播设施规模的增长，Roo Code 必须能够处理数千台设备和连接。

可扩展性：
微服务架构允许独立扩展各个服务 。   
IS-04 查询 API 分页和过滤功能可处理大型注册中心 。   
IS-05 批量操作可减少对单个设备进行多项更改时的负载 。   
为众多 UI 客户端和 IS-04/IS-07 订阅提供高效的 WebSocket 管理 。   
必要时采用数据库连接池和只读副本。
弹性：
微服务：单个非关键服务的故障不会导致整个系统停止运行 。   
IS-04 节点心跳机制允许检测注册中心故障；节点可以切换到备用注册中心。作为客户端，Roo Code 在知晓多个注册中心端点的情况下，也应能处理注册中心故障切换 。   
针对设备或注册中心的 API 调用采用重试机制 。   
针对可能发生故障的服务/设备调用采用断路器模式 。   
持久化数据存储允许 Roo Code 在重启后恢复其状态。
可扩展性并非事后添加的功能，而是一项核心设计原则。弹性确保作为关键基础设施的控制系统即使在网络或其自身组件部分发生故障时也能保持运行。NMOS 系统可能非常庞大 。Roo Code 必须表现良好。微服务通过允许扩展各个部分来提供帮助 。NMOS 本身具有可扩展性功能，如 IS-04 查询 API 过滤和 IS-05 批量操作 。Roo Code 应使用这些功能。为了实现弹性，如果某个微服务发生故障，其他微服务应继续运行 。如果 NMOS 注册中心发生故障，Roo Code 应检测到此情况，并在可用时切换到备份（类似于节点处理注册中心故障的方式 ）。   

5.4. 安全考量
在初始开发中，安全性往往被忽视，但对于生产系统而言至关重要。

安全通信：
实施 AMWA BCP-003-01：对所有 NMOS 通信（与注册中心、设备）以及 Roo Code 自身的 API（前端到后端）使用 TLS（REST API 使用 HTTPS，WebSocket 使用 WSS）。   
认证与授权：
如果 Roo Code 需要与安全的 NMOS API 交互，则考虑 AMWA BCP-003-02 和 IS-10 来授权 API 调用 。   
为访问 Roo Code Web UI 的用户实施稳健的认证机制。
在 Roo Code 内部实施基于角色的访问控制 (RBAC)，以根据用户角色（例如管理员、操作员）限制功能。
API 网关安全： API 网关应强制执行安全策略，验证令牌。
数据安全： 通过静态加密和适当的访问控制来保护数据库中的敏感数据（例如，如果存储了凭据、用户数据）。
从一开始就内置安全性，并遵循 AMWA 的最佳实践至关重要。虽然用户查询未明确要求 IS-10，但了解 BCP-003 至关重要。网络系统易受攻击。广播控制系统管理关键基础设施。因此，安全至关重要。AMWA 提供了安全指南（BCP-003-01 用于加密通信 ）。Roo Code 必须对其所有外部通信（与设备、注册中心）以及其自身的前后端链接使用 HTTPS/WSS。对 Roo Code 本身的用户访问必须经过身份验证和授权。   

6. 高层开发阶段与路线图
此分阶段方法允许增量交付价值并降低风险。首先建立核心功能，为更高级的功能提供基础。测试和安全性是持续关注的问题，但在后期阶段会有专门的重点。

阶段 1：核心后端实现 (IS-04 注册中心交互，基础 IS-05 客户端)
活动：
搭建微服务框架（或选定的后端结构）。
开发 NMOS 注册服务：发现注册中心 (DNS-SD)，实现 IS-04 查询 API 客户端，订阅 WebSocket 更新，填充内部 NMOS 资源清单。
开发基础连接管理服务：实现 IS-05 客户端逻辑，用于即时单播 RTP 连接 (SDP 处理)。
为 IS-04 资源和简单连接状态设计基础数据库模式。
建立这些服务之间的内部 API。
交付成果： 能够通过内部 API 调用发现 NMOS 设备并建立简单 A-B RTP 连接的后端。基础数据持久化。
重点： 建立基础的 NMOS 交互能力。
阶段 2：用于设备发现和手动路由的初始 Web UI
活动：
搭建前端框架 (例如 React)。
开发 API 网关。
实现用于以列表和基本拓扑形式显示已发现 IS-04 资源 (Node, Device, Sender, Receiver) 的 UI 组件。
实现手动路由 UI：选择 Sender 和 Receiver，通过后端触发即时 IS-05 连接。
在 UI 中实现 WebSocket 客户端，用于从后端通知服务获取实时状态更新。
交付成果： 功能性 Web UI，允许用户查看已发现的设备并执行手动 RTP 路由。设备状态和基本连接状态的实时更新。
重点： 提供核心用户可见性和控制能力。
阶段 3：IS-07 事件引擎和事件触发路由
活动：
开发事件处理服务：实现 IS-07 客户端逻辑 (通过 IS-05 进行 WebSocket/MQTT 订阅)。
处理和解释常见的 IS-07 事件 (初期专注于类似 Tally 的布尔事件)。
设计并实现用于将 IS-07 事件映射到 IS-05 动作的规则引擎/逻辑。
将事件处理服务与连接管理服务集成。
开发用于配置事件触发路由规则和查看 IS-07 事件日志/状态 (例如 Tally 显示) 的 UI 组件。
交付成果： 能够订阅 IS-07 事件并基于这些事件自动触发 IS-05 路由的后端。用于配置和监控此功能的 UI。
重点： 实现事件驱动自动化的关键高级功能。
阶段 4：IS-08 音频通道映射实现
活动：
开发音频映射服务：实现 IS-08 客户端逻辑。
与 IS-04 集成以发现支持 IS-08 的设备。
开发用于可视化和操作音频通道映射的 UI 组件。
将 UI 与音频映射服务集成。
交付成果： 通过 UI 控制兼容设备的音频通道映射 (静音、交换) 功能。
重点： 添加精细的音频控制。
阶段 5：高级功能、可扩展性测试和安全加固
活动：
实现高级 UI/UX 功能 (例如自定义视图、增强拓扑、高级搜索/过滤)。
如果尚未涵盖，则支持 IS-05 批量和延迟激活。
在负载下进行全面的可扩展性和性能测试。
全面实施安全性 (BCP-003、用户 RBAC、渗透测试)。
文档 (用户和开发者)。
部署脚本和基础设施设置 (例如 Docker、Kubernetes)。
交付成果： 可投入生产、可扩展、安全且文档齐全的 Roo Code 系统。
重点： 使产品成熟以供发布。
这种迭代过程允许反馈和过程修正。首先，确保系统能够感知网络 (IS-04) 并建立基本连接 (IS-05 后端)。其次，让用户能够看到这些信息并进行连接 (基础 UI)。接着，添加“智能”的事件驱动路由 (IS-07)。然后，加入更细致的控制，如音频映射 (IS-08)。最后，进行润色、规模测试、安全加固和文档编写。

7. 结论与建议
开发计划总结： 本计划重申了关键的架构选择（事件驱动的微服务、现代 Web UI）、基于 NMOS 标准的模块化开发以及分阶段的路线图。强调此计划为开发 Roo Code 提供了坚实的基础。
对 Roo Code 项目团队的主要建议：
深入理解 NMOS： 确保开发团队彻底理解 IS-04、IS-05、IS-07 和 IS-08 的复杂性，包括其 API、数据模型和相互依赖关系。AMWA 文档  和实施指南  至关重要。   
优先考虑后端稳健性： NMOS 交互服务（发现、连接管理、事件处理）的可靠性至关重要。
迭代式 UI/UX 开发： 在 UI 设计过程中持续让最终用户或 UX 专家参与，以确保其满足“美观直观”的要求 。   
战略性利用开源资源： 使用开源 NMOS 工具（测试、模拟设备 ）进行开发和测试。仔细评估使用 nmos-cpp  或 nmos-js  等库作为参考或组件。   
拥抱自动化测试： 实施全面的单元测试、集成测试和端到端测试，包括使用 AMWA NMOS 测试工具  进行 NMOS 合规性测试。   
尽早规划可扩展性和安全性： 从第一阶段开始就将这些考虑因素融入设计中，而不是事后弥补。
项目启动的后续步骤：
组建具备后端（所选语言/框架、微服务、消息传递）、前端（所选 JS 框架）和数据库技术相应技能的开发团队。
建立开发、测试和 CI/CD 环境。
开始第一阶段微服务和数据库模式的详细设计。
获取或设置对 NMOS 注册中心和一些符合 NMOS 标准的设备（或使用 nmos-device-control-mock ）的访问权限，以进行初步开发和测试。   
Roo Code 的成功不仅取决于技术执行，还取决于对广播工作流程和用户需求的深刻理解。强烈建议在整个开发过程中与目标用户群保持持续沟通。本计划提供了一个技术路线图。为了使其成功，Roo Code 团队需要内化 NMOS 规范，构建坚实的后端，关注用户体验，明智地使用现有工具，进行彻底测试，并从一开始就考虑可扩展性和安全性。最后一步是组建团队并开始初步设计。